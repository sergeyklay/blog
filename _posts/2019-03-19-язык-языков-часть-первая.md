---
layout: post
title: Язык языков. Часть первая
date: '2019-03-19 10:06:34'
excerpt: >-
  Этой статьей я начинаю серию небольших статей,  посвященную формальным
  грамматикам, системам описания грамматик, BNF и синтаксису языков.
---
В этой статье объясняются грамматики и общие системы описания грамматик, такие как Backus-Naur Form (BNF), Extended Backus-Naur Form (EBNF) и регулярное расширение грамматики Backus-Naur Form (ABNF). Данный текст не претендует на академическую точность и носит скорее ознакомительный, водный характер.

Очевидно, что я не являюсь очевидцем тех или иных событий, которые опишу ниже. Всё, что вы узнаете из этой статьи, не является авторским текстом.

Прочитав эту статью, вы сможете идентифицировать и интерпретировать все часто используемые обозначения для грамматик. По мере повествования я буду указывать ссылки на дополнительные материалы, ознакомившись с которыми, вы сможете получить более исчерпывающую информацию.

Статья разбита на несколько частей. Это — первая часть.

## Мотивация

Причины, по которым вам может быть интересна или даже полезна данная статья мне не известны. На сегодняшний день, род моей деятельности тесно связан с разработкой нескольких языков. И при изучении данной темы мною двигала любознательность и желание понять истоки тех инструментов, которыми я ежедневно пользуюсь. Мне постоянно попадалась противоречивая информация относительно темы данной статьи. Знакомые, книги, интернет — неточности были везде. И из-за того, что противоречивости окончательно меня запутали, я решил как-то систематизировать свои знания, в том числе восполнить пробелы.

Я не хотел бы, да и не смог бы перечислять все возможные области человеческой деятельности, где предмет данной статьи может быть вам полезен. Однако вот некоторые из них:

* Вы занимаетесь разработкой статического анализатора кода
* Вы занимаетесь разработкой нового языка
* Вы хотели бы добавить новые возможности в текущий язык
* Вы занимаетесь синтаксическим анализом некоторого текста, например заголовки HTTP запросов
* Вы разрабатываете поддержку некоторого языка в Emacs/Vim/SublimeTesx/ItelliJ/Atom
* Вы разрабатываете новый шаблонизатор для вашего веб-фреймворка
* Вы хотели бы разработать клиент для обмена сообщениями с некоторым демоном, но для этого нужно научится читать из сокета, куда пишет демон
* Вы хотели бы иметь возможность “конвертировать” код на исходном языке из одной версии этого языка, в другую или даже в другой целевой язык
* Вы хотели бы глубже изучить используемый язык
* Все те области деятельности, где вы часто употребляете слово “распарсить” 

Итак, я надеюсь, я натолкну вас на любопытные умозаключения и дальнейшие исследования.

## Определение языка

В информатике языки определяют область вычислений. Например, областью вычислений языка SQL является база данных, а HTML используется как язык разметки веб-страницы.

Языки программирования, спецификация протоколов, языки запросов, форматы файлов, языки шаблонов, формальные языки, конфигурационные файлы, языки разметки, языки форматирования и мета-языки определяют способ, которым мы проводим вычисления. Все они накладывают некоторые требования (ограничения) к способу и области вычислений, фактически формируя то, как мы эти вычисления производим.

А что формирует сами языки? Что накладывает них ограничения и диктует правила? Языки определяются двумя вещами: /синтаксисом/ и /семантикой/. Под синтаксисом обычно понимают то, что с помощью языка можно выразить (сказать, написать), а семантика — это как следует интерпретировать выраженное. В идеальном мире и синтаксис, и семантика должным быть /формально/ определены. Когда в контексте языков говорят "формально", то подразумевают некоторое абстрактное описание, не привязанное к какой либо реализации.

И если с описанием семантики в современных реалиях всё достаточно сложно, то описание синтаксиса присутствует в каждом языке, путь даже и не всегда формально.

Описанием синтаксиса занимаются /грамматики/. Грамматики являются языками языков. За каждым языком стоит своя грамматика, которая определяет его структуру и набор допустимых лексем. Язык не может выйти за рамки своей грамматики и полностью ею формируется. Грамматика однозначно определяет язык, но один и тот же язык может быть порождён разными грамматиками.

Саму идею, как то описать и определить язык можно проследить по крайней мере до работ [Pāṇini](https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini) (древнеиндийского грамматика санскрита и известного ученого в индуизме, жившего где то между VII и IV веками до н.э.). Его нотация, описывающая нотацию санскритской структуры слова, по силе эквивалентна нотации, которую уже в наше время разработал [Джон Бэкус](https://en.wikipedia.org/wiki/John_Backus) и имеет много схожих свойств.

По широко известной [классификации](https://en.wikipedia.org/wiki/Chomsky_hierarchy) [Ноама Хомского](https://en.wikipedia.org/wiki/Noam_Chomsky), существует четыре вида грамматик:

1. Неограниченная
2. Контекстно-зависимая
3. Контекстно-свободная
4. Регулярная

В информатике наиболее распространённым типом грамматики является _контекстно-свободная грамматика_. Смысл термина "контекстно-свободная" заключается в том, что контекстно-свободные языки не позволяют выражать зависимость от контекста. Например в языке Си, выражение `a * b`, в зависимости от значений `a` и `b` может означать объявление указателя, либо мультипликативное выражение. Контекстно свободные грамматики являются ниспадающими, то есть некоторые объекты, обозначающие какую-либо сущность языка выражают в терминах других объектов, которые в свою очередь, можно выразить в терминах третьих объектов и так далее.

И в этой статье мы сфокусируемся именно на таких грамматиках. Контекстно-свободные грамматики достаточно богаты, чтобы описать рекурсивную синтаксическую структуру многих (хотя, конечно же, не всех) языков.

## Компоненты контекстно-свободной грамматики

Основным компонентом грамматики является набор правил.

Каждое правило имеет 2 части: (1) имя и (2) во что это имя разворачивается (расширяется) или другими словами, через что это имя определяется.

Например, если бы мы создавали грамматику, для обработки английского текста, мы могли бы создать правило вроде:

`существительное-фраза` (1) может выражаться через `артикль существительное` (2)

Вот так просто: сначала идёт `артикль`, а за ним идёт `существительное`. Из чего в конечном итоге мы можем сделать вывод, что "the dog" это `существительное-фраза`. Или, если мы описываем алгебраическое выражение, мы могли бы определить правило вроде этого:

`expression` может выражаться через `digit + digit` (_2 + 3_)

Здесь я сознательно упростил пример. Известно, что например символ `5` можно интерпретировать как выражение (_expression_), значением которого является число `5`. С другой стороны, последовательность символов `5 + 5` так же можно интерпретировать как выражение, но более сложное. В канонических текстах предыдущий пример записывают так:

`expression` может выражаться через `expression + expression`

Когда мы работаем с грамматическими элементами как с математическими объектами, то вместо написания "может выражаться через" или "определяется как" мы просто используем стрелку `→`:

```
существительное-фраза → артикль существительноеexpression → expression + expression
```

Определение, которое стоит по правую сторону от стрелки, может быть и сложнее. Например, если мы посмотрим на формулу площади равнобедренного треугольника:

```
S = 1/2 * a^2 * sinα
```

То становится очевидным, что некоторые части выражения имеют рекурсивный характер с точки зрения описательной грамматики:

```
S → expressionexpression → expression * expression
```

Выражение одного объекта чрез другой принято называть _продукцией_. Главное практическое условие при составлении грамматики — она должна быть полной, то есть описывать все возможные ситуации входного потока.

В качестве примера рассмотрим классическую грамматику однозначного выражения:

```
test1test2test3test4
```

```
expr → term + exprexpr → termterm → term ∗ factorterm → factorfactor → (expr)factor → constconst → integer
```

Первая и вторая строки описывают две возможные ситуации входного потока:

1. `expr` выражается через `term`, за которым следует символ `+`, за которым следует `expr`
2. `expr` выражается через `term`

По другому на это можно смотреть так: выражение (`term`) это либо (1) либо (2). Шаг за шагом мы выражаем "сложное" через "более простое". Хотя на практике это и не всегда так — мы можем выражать один объект через другой, не обязательно являющийся более простым.

На каждом шаге мы производим ровно одну продукцию. В конечном итоге, мы доходим до атомов, которые являются значениями сами по себе и уже ни через что не выражаются. Такие атомы в нотации формальных грамматик называются _терминалами_. А то, что можно выразить, через другие объекты, называется _нетерминалами_.

Выведем правило:

* **Терминал** (_терминальный символ_) — объект, непосредственно присутствующий в словах языка, соответствующего грамматике, и имеющий конкретное, неизменяемое значение.
* **Нетерминал** (_нетерминальный символ_) — объект, обозначающий какую-либо сущность языка (например: формула, арифметическое выражение, команда) и не имеющий конкретного символьного  значения.

Итак, как же мы можем понять, что запись `3 * 7` является допустимым выражением? Мы просто произведём некоторое количество продукций, конечным результатом которых будет доказательство, что мы имеем дело с допустимым выражением:

1. Мы знаем, что `expr` может выражаться через `term`
2. Что, в свою очередь может выражаться через `term ∗ factor`
3. Что может выражаться через `factor ∗ factor`
4. Что может выражаться через `const ∗ factor`
5. Что может выражаться через `const ∗ const`
6. Что может выражаться через `3 ∗ const`
7. Что может выражаться через `3 ∗ 7`

За 7 шагов продукции мы доказали, что `3 * 7` является допустимым выражением. При определённой сноровке, мы могли бы произвести эти шаги в обратном порядке.

Важно отметить, что в любой грамматике, в т.ч. и в контекстно-свободной, обязательно должен быть стартовый нетерминал. Самая высшая абстракция, то, с чего всё начинается.
