---
layout: post
title: Язык языков. Часть вторая
date: '2019-06-28 10:50:18'
featured_image: /images/bookcase-books.jpg
excerpt: >-
  Вторая часть статьи посвящённой формальным
  грамматикам, системам описания грамматик, BNF и синтаксису языков.
---
Данная статья является продолжением моих исследований в области формальных грамматик. Если вы не читали [первую часть](https://serghei.blog/post/%D1%8F%D0%B7%D1%8B%D0%BA-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F), то я рекомендую вернуться назад и прочесть сначала её, а затем продолжить с этой статьи. В противном случае некоторые вещи вам могут показаться не понятными либо не полностью раскрытыми.

## META II

В 1963-1964 годах, буквально через несколько лет после появления BNF, за авторством Dewey Val Schorre работавшим тогда в Калифорнийском университете в Лос-Анджелесе ([UCLA](http://www.ucla.edu/)) выходит в свет язык программирования META II. Примечательно, что в 1963 году была разработана и стандартизована ASCII-таблица.

Основная сфера применения этого языка — создание компиляторов. В документации по языку, META II описывается как «_Cинтакс-ориентированный язык для написания компиляторов_», а так же «_язык похожий на BNF_». В этом языке были введены такие понятия и конструкции, которые в том или ином виде дожили и до наших дней в виде продолжения в EBNF и ABNF, о которых мы поговорим ниже.

В META II рекурсивное определение BNF было заменено циклом. Для этого была введена математическая группировка при помощи скобок `$(` и `)`. Фактически, следующее выражение:

```
$(foo)
```

следует понимать как ноль или более повторений `foo`. Например, для следующего BNF правила:

```
<expr> := <term> | <expr> + <term> | <expr> - <term>
```

мы должны были бы написать что-то вроде:

```
expr = term
       $( '+' term .out('ADD')
        / '-' term .out('SUB'));
```

На что тут следует обратить внимание:

* Символы целевого языка (терминалы), стали определяться с помощью строк в одинарных кавычках (здесь это `+` и `-`)
* Были удалены угловые скобки, что наложило ограничения на допустимый набор символов
* Металингвистическая связка `::=` была заменена на `=`
* Для указания выбора используется наклонная черта (`/`) вместо вертикальной (`|`)
* Правило заканчивается точкой с запятой (`;`)
* Отныне пользователю предлагались _уравнения_, вместо _металингвистических правил_, как это называлось в BNF

Рассмотрим шаг за шагом как работает грамматика, приведённая выше.

Выражение оценивается слева направо. Первое, что проверяется это `term`. Если сопоставление с `term` не удалось, всё выражение откидывается и анализатор двигается дальше. Если сопоставление оказалось успешным, анализатор входит в `$( … )`. Затем анализатор пытается протестировать `+`. В случае неудачи срабатывает альтернатива (`/`) и анализатор оценивает `-`. Если хоть один из вариантов сопоставления с образцом оказался успешным, анализатор пытается провести сопоставление с тем `term`, который находится по правую сторону от знака. Если оба варианта сопоставления не удались, т.е. вторые `term` не удалось сопоставить, результат сопоставления остаётся успешным только для самого первого `term`, который мы видим сразу же после знака `=`. Тут всё достаточно просто. А теперь самое интересное. Так как оператор `$(  )` означает _цикл из нуля или более итераций_, то после успешного сопоставления со вторым `term`, цикл повторяется до тех пор, пока сопоставление не провалится. Так решалась задача рекурсивных определений BNF.

Любопытные штуки типа `.out('ADD')`, как мог догадаться читатель — служебный код, печатающий т.н. опкоды в стандартный вывод. Работало это так: если сопоставление удалось полностью, например - `term`, то печатаем `SUB`.

Мне показался забавным тот факт, что в документации указанно об обязательной точке с запятой в конце каждого уравнения, однако в самой документации, вместо этого используется точка, за которой сразу идёт запятая («_due to keypuch limitations_»). Вспомнилось, что в отчёте ALGOL 60 таких проблем не было. Там всё решалось ручным написанием всех нужных закорючек.

Если бы мы хотели как-то обозначить синтаксический элемент необязательным, в META II нам предлагалось использовалось служебное слово `empty`:

```
subsecondary = '*' primary / empty  ;
   secondary = primary subsecondary ;
```

Первую строку следует понимать так: либо символ `*`, за которым идёт нетерминал `primary`, либо ничего.

Кроме того, в META II появилось три типа данных: идентификаторы (обозначались через `id`), строки (обозначались через `string`) и числа (обозначались через `number`). Теперь давайте рассмотрим следующий пример целевого языка:

```
A
A + B
A + B * C
(A + B) * C
```

Это выдуманный алгебраический язык, с приоритетом операторов и группировкой. Если бы мы хотели покрыть этот язык грамматикой используя META II, то нам понадобилось бы написать следующий набор уравнений:

```
expr3 = id / '(' expr1 ')'        ;
expr2 = expr3 ('*' expr2 / empty) ;
expr1 = expr2 ('+' expr1 / empty) ;
```

Это в действительности не сложная грамматика. И если присмотреться, то всё становится достаточно очевидным, кроме одного понятия, с которым мы ещё не сталкивались — группировка. Только на первой строке скобки обрамлены кавычками, указывая на принадлежность скобок к символам целевого языка. Группировку скобками на второй и третьей строке следует расценивать так — сопоставление с группой считается успешным только в случае полного сопоставления с каждой альтернативой внутри группы.

Если BNF был формальным языком, не привязанным к каким либо реализациям и вычислениям, то в META II мы видим как ситуация стала меняться.

Остальной синтаксис META II не сложнее чем то, что я уже показал, а сам язык обладает богатыми возможностями. Но надолго останавливаться на нём мы не будем. Я лишь хотел показать некоторые черты, которые мы рассмотрим далее.

Позднее, уже в 1970-ых, появилась небезызвестная утилита [yacc](https://en.wikipedia.org/wiki/Yacc), использующая BNF продукции очень похожие не те, которые использовались в META II. yacc чаще всего используется в качестве генератора [LALR-парсеров](https://en.wikipedia.org/wiki/LALR_parser), и корнями, очевидно, уходит в BNF. Когда вы где-то слышите или читаете, что yacc использует BNF, то знайте — только от части, оригинальный BNF был совсем другой.